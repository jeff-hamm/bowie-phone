#include <config.h>
#include "dtmf_decoder.h"
#include "AudioTools.h"
#include "AudioTools/AudioLibs/AudioBoardStream.h"
#include "AudioTools/AudioLibs/AudioRealFFT.h" // or AudioKissFFT
#include "AudioTools/Disk/AudioSourceSDMMC.h" // SD_MMC mode
#include "AudioTools/AudioCodecs/CodecMP3Helix.h"

#include "sequence_processor.h"
#include "special_command_processor.h"
#include "audio_file_manager.h"
#include "wifi_manager.h"
#include "logging.h"
#include "phone_service.h"
#include "audio_player.h"
#include <WiFi.h>
#include <SPI.h>
#include <SD.h>
#include <SD_MMC.h>

AudioBoardStream kit(AudioKitEs8388V1); // Audio source
AudioRealFFT fft;                       // or AudioKissFFT
StreamCopy copier(fft, kit);            // copy mic to tfl
int channels = 2;
int samples_per_second = 44100;
int bits_per_sample = 16;

// Audio playback components

const char *startFilePath="/";
//const char* ext="mp3";
AudioSourceSDMMC source(startFilePath);
MP3DecoderHelix decoder;  // or change to MP3DecoderMAD

// DTMF sequence configuration
const unsigned long SEQUENCE_TIMEOUT = 2000; // 2 seconds timeout
const int MAX_SEQUENCE_LENGTH = 20;          // Maximum digits in sequence
char dtmfSequence[MAX_SEQUENCE_LENGTH + 1];  // +1 for null terminator
int sequenceIndex = 0;
unsigned long lastDigitTime = 0;
/*
 * Audio Input Device Options (configurable via AUDIO_INPUT_DEVICE build flag):
 * 
 * ADC_INPUT_LINE1 - Microphone only (0x2020)
 * ADC_INPUT_LINE2 - Line in only (0x0408) 
 * ADC_INPUT_LINE3 - Right mic + left line in (0x0420)
 * ADC_INPUT_ALL   - Both microphone and line in (0x0408 | 0x2020) [DEFAULT]
 * 
 * Set via platformio.ini build_flags:
 * -DAUDIO_INPUT_DEVICE=ADC_INPUT_LINE2  ; for line in only
 */

// Flag to track if audio kit has been initialized
static bool audioKitInitialized = false;

// Helper function to setup audio input and FFT (called after audio playback ends)
void setupAudioInput()
{
    // Setup audio input (DTMF detection)
    // Note: Using TX_MODE for SD_MMC compatibility - DTMF may need alternative approach
    auto cfg = kit.defaultConfig(TX_MODE);
    
    // Configure input device - can be set via build flags
#ifdef AUDIO_INPUT_DEVICE
    cfg.input_device = AUDIO_INPUT_DEVICE;
#else
    cfg.input_device = ADC_INPUT_ALL; // Default: both microphone and line in
#endif
    
    cfg.channels = channels;
    cfg.sample_rate = samples_per_second;
    cfg.bits_per_sample = bits_per_sample;
    cfg.sd_active = false; // SD card initialized manually in setup()
    kit.begin(cfg);

    // Setup FFT
    auto tcfg = fft.defaultConfig();
    tcfg.length = 8192;
    tcfg.channels = channels;
    tcfg.sample_rate = samples_per_second;
    tcfg.bits_per_sample = bits_per_sample;
    tcfg.callback = &fftResult;
    fft.begin(tcfg);
}

// Audio event callback - called when audio starts/stops
void onAudioEvent(bool started)
{
    if (!started)
    {
        // Audio finished - restart input audio system and FFT processing
        setupAudioInput();
        Logger.println("üé§ Resumed audio input and FFT processing");
    }
}

// Check for new DTMF digits and manage sequence collection
// Returns true when a complete sequence is ready to process
bool checkForDTMFSequence()
{
    static unsigned long lastAnalysisTime = 0;
    unsigned long currentTime = millis();

    // Analyze DTMF data every 50ms
    if (currentTime - lastAnalysisTime > 50)
    {
        char detectedChar = analyzeDTMF();
        if (detectedChar != 0)
        {
            Serial.printf("DTMF digit detected: %c\n", detectedChar);

            // Add digit to sequence
            if (sequenceIndex < MAX_SEQUENCE_LENGTH)
            {
                dtmfSequence[sequenceIndex] = detectedChar;
                sequenceIndex++;
                dtmfSequence[sequenceIndex] = '\0'; // Null terminate
                lastDigitTime = currentTime;
                Serial.printf("Added digit '%c' to sequence: '%s'\n", detectedChar, dtmfSequence);
            }
        }
        lastAnalysisTime = currentTime;
    }

    // Check if sequence is complete (timeout or buffer full)
    if (sequenceIndex > 0 &&
        ((sequenceIndex == MAX_SEQUENCE_LENGTH - 1) ||
         (currentTime - lastDigitTime > SEQUENCE_TIMEOUT)))
    {

        Serial.printf("Sequence complete: timeout or buffer full\n");
        return true; // Sequence ready to process
    }

    return false; // No complete sequence yet
}




void setup()
{
    Serial.begin(115200);
    delay(2000); // Give serial time to initialize

    // Initialize logging system first
    Logger.addLogger(Serial);

    Logger.printf("\n\n=== Bowie Phone Starting ===\n");
    Logger.println("=== SD CARD DIAGNOSTIC MODE ===");
    Logger.println("Testing both SPI and SD_MMC modes every 2 seconds");
    Logger.println("Press reset when SD works to continue normal boot.\n");
    AudioToolsLogger.begin(Serial, AudioToolsLogLevel::Warning);

    // Continuous test loop - try both SPI and SD_MMC modes
    int testAttempt = 0;
    while (true) {
        testAttempt++;
        
        Logger.printf("\n--- Attempt #%d ---\n", testAttempt);
        
        // First try SPI mode (uses GPIO13 as CS, which matches switch labels)
        Logger.println("Trying SD SPI mode (CS=13, CLK=14, MOSI=15, MISO=2)...");
        SPI.begin(14, 2, 15, 13);  // CLK=14, MISO=2, MOSI=15, CS=13
        if (SD.begin(13, SPI)) {
            uint64_t cardSize = SD.cardSize() / (1024 * 1024);
            Logger.printf("‚úÖ SUCCESS with SPI mode! SD card size: %lluMB\n", cardSize);
            Logger.println("üéâ SD card is working in SPI mode!");
            SD.end();
        } else {
            Logger.println("‚ùå SPI mode failed");
            SD.end();
        }
        
        delay(500);
        
        // Then try SD_MMC 1-bit mode
        Logger.println("Trying SD_MMC 1-bit mode (CMD=15, CLK=14, D0=2)...");
        if (SD_MMC.begin("/sdcard", true)) {
            if (SD_MMC.cardType() != CARD_NONE) {
                uint64_t cardSize = SD_MMC.cardSize() / (1024 * 1024);
                Logger.printf("‚úÖ SUCCESS with SD_MMC! Card size: %lluMB\n", cardSize);
                Logger.println("üéâ SD card is working in SD_MMC mode!");
                SD_MMC.end();
            } else {
                Logger.println("‚ùå SD_MMC.begin() succeeded but no card detected");
                SD_MMC.end();
            }
        } else {
            Logger.println("‚ùå SD_MMC mode failed (0x107 timeout)");
            SD_MMC.end();
        }
        
        delay(1500);  // Total ~2 seconds between full cycles
    }
    // Code below won't run until you remove the while(true) loop

    // Explicitly configure SD_MMC pins with proper pull-ups before initialization
    // ESP32 SD_MMC 1-bit mode uses: GPIO15 (CMD), GPIO14 (CLK), GPIO2 (D0)
    Logger.println("üîß Configuring SD_MMC pins...");
    
    // Try multiple times with increasing delays
    bool sdInitialized = false;
    for (int attempt = 1; attempt <= 3 && !sdInitialized; attempt++) {
        Logger.printf("üîß SD_MMC initialization attempt %d/3...\n", attempt);
        delay(attempt * 500);  // Increasing delay: 500ms, 1000ms, 1500ms
        
        // Initialize SD_MMC in 1-bit mode
        if (SD_MMC.begin("/sdcard", true)) {  // true = 1-bit mode
            if (SD_MMC.cardType() != CARD_NONE) {
                uint64_t cardSize = SD_MMC.cardSize() / (1024 * 1024);
                Logger.printf("‚úÖ SD_MMC initialized (1-bit mode, %lluMB) on attempt %d\n", cardSize, attempt);
                sdInitialized = true;
            } else {
                Logger.println("‚ùå No SD card detected");
                SD_MMC.end();
            }
        } else {
            Logger.println("‚ùå Failed to initialize SD_MMC");
            SD_MMC.end();  // Clean up before retry
        }
    }
    
    if (!sdInitialized) {
        Logger.println("‚ö†Ô∏è SD_MMC initialization failed after all attempts - continuing without SD card");
    }

    // Add more startup delay for system stabilization
    Logger.println("üîß Allowing system to stabilize...");
    delay(3000);

    // Initialize AudioKit with sd_active=false since we already initialized SD_MMC
    // Using TX_MODE like Pheromone Dating - RXTX_MODE may conflict with SD_MMC pins
    Logger.println("üîß Initializing AudioKit (TX_MODE)...");
    auto cfg = kit.defaultConfig(TX_MODE);
    
    // Configure input device - can be set via build flags
#ifdef AUDIO_INPUT_DEVICE
    cfg.input_device = AUDIO_INPUT_DEVICE;
#else
    cfg.input_device = ADC_INPUT_ALL; // Default: both microphone and line in
#endif
    
    cfg.channels = channels;
    cfg.sample_rate = samples_per_second;
    cfg.bits_per_sample = bits_per_sample;
    cfg.sd_active = false; // SD card already initialized manually above
    if (!kit.begin(cfg))
    {
        Logger.println("‚ùå Failed to initialize AudioKit");
    }
    else
    {
        Logger.println("‚úÖ AudioKit initialized successfully");
    }

    // Initialize audio file manager (CS pin ignored for SD_MMC mode)
    initializeAudioFileManager(13, true); // 13=CS pin (ignored), true=use SD_MMC

    // Initialize Audio Player with event callback
    initAudioPlayer(source, kit, decoder);
    setAudioEventCallback(onAudioEvent);

    // Setup FFT for DTMF detection
    auto tcfg = fft.defaultConfig();
    tcfg.length = 8192;
    tcfg.channels = channels;
    tcfg.sample_rate = samples_per_second;
    tcfg.bits_per_sample = bits_per_sample;
    tcfg.callback = &fftResult;
    fft.begin(tcfg);

    Logger.println("üé§ Audio system ready!");

    // Initialize WiFi with careful error handling
    Logger.println("üîß Starting WiFi initialization...");
    initWiFi();

    // Initialize OTA updates (must be after WiFi)
    initOTA();

    // Initialize special commands system
    initializeSpecialCommands();

    // Initialize Phone Service
    Phone.begin();
    Phone.setHookCallback([](bool isOffHook) {
        if (isOffHook) {
            // Handle off-hook event - play dial tone
            Logger.println("‚ö° Event: Phone Off Hook - Playing Dial Tone");
            playAudioBySequence("dialtone1");
        } else {
            // Handle on-hook event - stop audio, reset state
            Logger.println("‚ö° Event: Phone On Hook");
            stopAudio();
            // Reset DTMF sequence
            sequenceIndex = 0;
            dtmfSequence[0] = '\0';
        }
    });
    
    Logger.println("‚úÖ Bowie Phone Ready!");
}

void loop()
{
    // Handle WiFi management (config portal and OTA)
    handleWiFiLoop();

    // Ensure audio catalog/downloads kick off once WiFi is available
    static bool audioDownloadComplete = false;
    static unsigned long lastAudioDownloadAttempt = 0;
    const unsigned long audioDownloadRetryMs = 30000; // retry every 30s if needed

    if (!audioDownloadComplete && WiFi.status() == WL_CONNECTED)
    {
        unsigned long now = millis();
        if (lastAudioDownloadAttempt == 0 || (now - lastAudioDownloadAttempt) > audioDownloadRetryMs)
        {
            lastAudioDownloadAttempt = now;
            if (downloadAudio())
            {
                audioDownloadComplete = true;
            }
        }
    }
    if(!Phone.isRinging())
        Phone.startRinging();

    // Process Phone Service
    Phone.loop();
    
    // Skip other processing if in config mode
    // if (isConfigMode)
    // {
    //     return;
    // }

    // Process audio download queue (non-blocking)
    static unsigned long lastDownloadCheck = 0;
    if (millis() - lastDownloadCheck > 1000) // Check every second
    {
        processAudioDownloadQueue();
        lastDownloadCheck = millis();
    }

    // Only process if phone is off hook
    // if (!Phone.isOffHook())
    // {
    //     return; // Phone is on hook, nothing to do
    // }

    // Handle audio playback
    if (isAudioActive())
    {
        processAudio();
    }
    else
    {
        // Only process DTMF when not playing audio
        // Process audio - FFT callback collects frequency data
        copier.copy();
        
        // Check for complete DTMF sequences
        if (checkForDTMFSequence())
        {
            // Process the complete sequence and check for audio playback
            const char* audioPath = processNumberSequence(dtmfSequence);
            
            // If an audio file path was returned, start playback
            if (audioPath && SD_MMC.exists(audioPath))
            {
                playAudioPath(audioPath);
            }

            // Reset sequence buffer for next sequence
            sequenceIndex = 0;
            dtmfSequence[0] = '\0';
        }
    }
}